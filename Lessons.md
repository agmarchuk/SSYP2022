## Информационные и учебные материалы к проекту "ЛШЮП Информбюро"

### Основные черты проекта
Ставится задача: создать информирующую систему для Школы юных программистов и ее летних сборов. Система должна быть выполнена в современных технологиях C#, .NET, Blazor, база данных PolarDB. Итоговый результат: система с Web-доступом, поддерживающая несктолько информационных процессов таких как, поток новостей, площадка (Chat) коммуникаций, ввод мультимедиа документов в архив данных, редктирование данных, интерфесы выборки документов и данных по запросам. 

### Как подготовиться к работе в мастерской
Для участия в проекте надо в какой-то мере познакомиться с известными технологиями:
- C# - есть множество учебных материалов в Интернете, есть лекции мастеров ЛШЮП
- HTML - есть множество учебных материалов в Интернете, я рекомендую https://webref.ru/course/html-tutorial. 
- ASP.NET Core Blazor. Технлогия довольно объемная, материал будет даваться по необходимости, для продвинутых школьников можно рекомендовать документацию и учебные материалы Microsoft https://dotnet.microsoft.com/en-us/learn/aspnet/blazor-tutorial/intro. Есть также разбросанные материалы по Blazor, поиск которые выполняется по необходмости. Мне например, понадобился материал https://www.youtube.com/watch?v=I7gBTLeiHG8.
- LINQ - это слой функционального программирования в C#, он в данном проекте ТОЛЬКО для подготовленных школьников. Материалов по LINQ в Интернете много.
- еще нам понадобится знание основ клиент-серверных технологий, если у Вас есть что почитать, почитайте, эти технологии сейчас доминируют в программном обеспечении, расчитанном на информационное обслуживание человека. 
- Надо изучить данное пособие https://github.com/agmarchuk/Ssyp2022/blob/main/Lessons.md, в нем мало лишнего, информация дается популярно.

### Немножко C#. Тесты на C#, LINQ
Обязательно надо познакомиться с программированием консольного приложения. Запускаем VisualStudio, формируем новый проект по шаблону "Консольное приложение", получаем простейшую программу Hello World!, Нажимем на зеленый треугольник, убеждаемся, что программ работае, внутри этой программы пишем свои тесты для того, чтобы потренироваться в работе с C#. После каждогонвого фрагмента, исполняем программу (нажимаем на зеленый треугольник), убеждаемся, что вычислены результаты, которые ожидались.

Необходимо в консольном приложении сделать следующие тесты: 
1)	Завести массив целых, заполнить его несколькими значениями. Произвести фильтрацию потока, оставив только четные, произвести функциональное преобразование потока, напр. возведение в квадрат, вычислить сумму элементов.  
2)	Задать длину последовательности, сгенерировать поток из этого числа псевдослучайных целых значений, убрать повторы, сделать функциональное преобразование потока, породив из случайного числа запись { id, name, age } в которой id – это случайное значение, name – строковое значение этого случайного значения, age – случайное значение в диапазоне 1-100. Далее, отсортировать поток записей по id, превратить в массив записей.
3)	Делается процедура получения записи по идентификатору из массив записей предыдущего примера.

### Начало работы
Для работы и для обучения нам понадобятся программные средства. Для новичков рекомендуется VisualStudio 2019 с достаточно свежими обновлениями. Надеюсь установка студии у вас получится, если будут трудности, обращайтесь к старшим.

Запускаем студию, нам надо создать новый проект (нажмите выделение "Создание проекта"). Чтобы нам не изучать лишнего, выбирайте проект по шаблону "Приложение Balzor Server", найдите этот вариант в правом списке, нажмите на вариант и "далее". Заполните Название проекта, напр. я назвал "KostyaStart", нажмите далее. Следующую страницу настройки пропустите и нажмите Создать. Для дальнейшего вам понадобится немного ориентироваться в файлах, которые вы с системой создаете и проходить простой цикл редактирование - исполнение. Ориентирование происходит в панели "Обозреватель решения", редактирование осуществляется после выделение в панели нужного файла. Исполнение (попытка исполнения) выполняется через команду нажатием на команду Отладка/Начать отладку или, что проще через нажатие зеленого треугольника. 

VisualStudio годится как для работы профессионалов, выполняющих сложные действия по разработке и отладке, так и для новичков. Поэтому, проект, который вы породили, уже готов к исполнению, нажимаем на зеленый треугольник. Если у вас "правильная" студия, то начнутся процессы компиляции и исполнения. Что вы ждете? - нажимайте! 

Через несколько секунд (до минуты) появится окно браузера в котором будет "блистать" всеми любимое приветствие миру. Основа проекта сделана, в дальнейшем будут вноситься разные элементы и разная функциональность, но программный результат будет именно такой: блазор-проект, которые запускается и появляется интерфейс с программой через ваш браузер. Интерфейс позволит просматривать предоставленную информацию, вводить свою информацию, делать запросы и получать ответы. Но это потом. А сейчас посмотрим что у нас получилось? VisualStudio запустила программу, которая называется сервером или сервисом. Эта программа - главная во всем процессе. А вот то, что изображается в браузере, это другая часть информационной системы - так называемый "клиент". 

Если сервис правильно оформлен, а мы в дальнейшем разберемся с этим вопросом, то с ним может связаться ЛЮБОЙ человек, подключенный к Интернету в (почти) любой точке мира. Связаться через браузер. Для этого он должен в своем браузере набрать командрую строку типа той, что есть в вашем запуске. Проверим это. Запустите браузер на вашем компьютере, лучше другой, не тот который автоматически запустился. Скопируйте (знаменитым copy-past) содержимеое адресной строки, нажмите enter и другое окно будет также соединено с вашей (пока не совсем вашей) программой. Понажимайте управление в интерефейсах, работают они независимо и не мешая друг друго. Это и есть "Клиент-серверные технологии", про которые вы наверняка слышали. А еще вы слышали такое словосочетание, как Web-приложение. Так это оно и есть... Не пугайтесь, пока ваше приложение во внешнем мире не видно. 

Теперь давайте посмотрим через "Обозреватель решений" на те файлы, которые кем-то созданы для того, чтобы "легким движением руки" вы получили бы действующее Веб-приложение. Несколько папок, много файлов... Не пугайтесь, ничего особо сложного в них нет, что нужно освоим, остальное пусть будет так как есть. Обратите внимание на файлы Pages/*.razor. Это и есть страницы, которые может формировать программа и формирует по запросу. Обратите внимание, на то, что переключаясь со страницы на страницу через навигационное меню, мы попадаем в разнные разделы (Pages), в которых совсем разное содержимое. Это видно, если вы переключаясь через меню обращаете внимание на адресную строку, напр. https://localhost:44305/, https://localhost:44305/counter, ... Вы можете без меню набирать эти адреса и попадать в нужные страницы. А страницы называются Pages/Index.razor для страницы привествия, Pages/Counter.razor и т.д. А если вы заглянете в файл Shared/NavMenu.razor, вы увидите как строится меню, хотя сейчас это не существенно. После выключения сервера, клиент получает что попало, но можно изменить тексты программ страниц и снова запускать сервер. Сервер выключается при нажатии на красный квадратик или если закрыть открытое сервером окно браузера. Если вы не "напортачите" при мелких изменениях, страницы будут работать после новых запусков.         

### Урок 1. Разминка
Первый урок у нас будет "разминкой", т.е. не основным действием, а лишь подготовкой к нему. Для экспериментов рекомендуем использовать файлы основных страниц. Они нам в разработке не понадобятся и на них экспериментировать вполне безопасно. Пока не будем вчитываться в то, что написано в этих файлах, а будем и смело очищать от предыдущего текста. Проще всего проводить эксперименты с индексной странцией Index.razor. Это потому, что именно она автоматически запускается первой. Рассмотрим что находится на странице Index.razor? На странице есть три части. Первая заголовок: @page "имя страницы". Вторая часть - HTML-текст, порождающий изборажение в браузере. Этот html осовобожден от технических моментов общей организации, в нем может быть только то, что нужно именно для данной композиции. Третья составляющая razor-файла - это программный код, погруженный в скобки @code{ ... }. 

Мы будем учиться строить изображение и только изображение. Программный  код в этой разминке будет пустой. Представим, что индексная страница и есть цель нашего большого проекта. Вы можете проявить творчество в том, чтобы создать макет страницы, которая, как вам кажется, будет хорошо соответствовать замыслу проекта. Наша задача - разбить поле страницы на части, которые будут в совокупности порождать нужную композицию. Поскольку это макет, желательно, чтобы некоторое текстовое наполнение присутствует. Это наполнение можно брать откуда угодно, сейчас это не важно. Важен лишь общий вид композиции. Попробуем собрать то, что нам нужно из элементов <div></div>. Внутри данных скобок могут быть тексты и вложенные элементы div. Важной особенностью элемента является то, что он всегда порождает прямоугольник. Оставим в файле Index.razor только первую строку. А вместо остального, вставим что-нибудь вроде: 
```
<div style="border: 1px solid black;">
    Класс компонента обычно записывается в виде страницы разметки Razor с расширением файла .razor. 
    Компоненты в Blazor обычно называются Blazor (или Razor). 
    Синтаксис Razor сочетает разметку HTML с кодом C#, позволяя повысить производительность разработчиков. Razor позволяет 
    переключаться между разметкой HTML и кодом C# в одном файле благодаря программной поддержке Razor в Visual Studio. 
    Синтаксис Razor применяется также для Razor Pages и MVC. 
    В отличие от Razor Pages и MVC, которые построены по модели "запрос-ответ", 
    компоненты используются специально для логики пользовательского интерфейса на стороне клиента и для компоновки.
</div>
```
И после этого, запустим сервер. За счет специального оформления границ, мы можем наблюдать как выглядит блочная структура. Стандартные блоки div занимают всю доступную полосу. Но есть другие блоки - блоки-кирпичи, они укладываются в объемлющий блок слева направо, сверху вниз. Таким блокам можно присваивать один или два размера. Например, для предыдущего примера в стилевое оформление блока добавим "display: inline-block; float: right; width: 200px;" и мы увидим узкий блок, прижатый вправо. 

А можно сработать и без текстов, только тогда надо более определенно назначать размеры блоков, заодно добавим еще и нижнюю панель, напр.
```
<div style="border: 1px solid black;">
    <div style="display: inline-block; float: left; height:300px; width:40%; border: 1px solid black;">
        Это левая панель
    </div>
    <div style="display: inline-block; float: right; height: 300px; width: 60%; border: 1px solid black;">
        Это правая панель
    </div>
</div>
<div style="border: 1px solid black;">
    Это нижняя панель
</div>
```
Таким образом, мы разрарабатываем систему панелей, в которые надо вкладывать содержимое. Это будет делаться в следующем уроке.

### Урок 2. Вставление данных в композицию
Фиксировать данные, которые попадают в композицию целесообразно только для простых статических сайтов. В остальных случаях, и в нашем тоже, данные должны программно вычисляться и внедряться в лэйаут композиции. Средствами Блазора это делается довольно просто. Для этого используется секция кода. В этой секции определяются переменные, которые каким-то образом вычисляются, а потом эти переменные помещаются в композицию. Например, для нашей учебной разработки, сделаем код:
```
@code{
    string left_panel = @"Класс компонента обычно записывается в виде страницы разметки Razor с расширением файла .razor. 
    Компоненты в Blazor обычно называются Blazor (или Razor).";

}
``` 
а в первый внутренний div внедрим значение этой переменной:
```
<div ...>
    @(left_panel)
</div>
```
Попробуйте. Всякий раз, когда будет вычисляться новое значение левой панели, оно (автоматически) будет переноситься в html код.

Какие виды информации можно располагать в композиции. Вы их знаете, это: тексты, имиджи (фотки), гиперссылки, таблицы, списки. Попробуем вставить фотографию во вторую панель композиции. Большинство умеет это делать, надо просто вставить элементimg:
соответственно, надо фотографию куда-то поместить и по какому-то uri к ней обратиться. Основной способ для Блазора такой же как и для других ASP.NET технологий: фотография помещяется в папку wwwroot и uri к ней формируется как путь к файлу относительно wwwroot. Пользуясь средствами операционной системы, найдем папку KostyaStart/wwwroot, в ней заведем подпапку images, в которую поместим выбранную тестовую фотку. А потом сделаем на нее ссылку img, только не забудем указать размер, а то фотография може не поместиться в отведенное место и собъет нашу композицию. 
```
  <img src="/images/test-photo.jpg" width="200"/>
```
Следующий вариант формирования того, что вставить в нашу композицию, это вложенная композиция. То есть мы можем в некоторый блок (div) вставить ряд полей. Мы уже умеем (немного) управлять размещением, умеем располагать текст и умеем располагать имиджи. Для удобства, информационные поля можно описать классом, а потом завести переменную этого класса и определеить ее значение, напр.:
```
    class Person
    {
        public string name;
        public string birth;
        public string uri;
    }
    Person ivanov = new Person() 
    { name = "Иванов Иван Иванович", birth = "2008", uri = "/images/test-photo.jpg" };
```   
Поскольку кодовая часть тесно связана с html, теперь в тексте html мы можем брать переменную, брать ее поля и, как мы уже умеем, изображать эти поля в виде html-композиции. Соорудим эту композицию в левой панели, за тем текстом, который там уже есть. 

На самом деле, внедрение вычисленных значений в HTML это не единственный способ взаимодействия C# и HTML. Разработан способ (целый язык, называемый razor!) для совмещения кода C# и HTML. В принципе, в нем все достаточно просто, на примерах вы поймете принципы. Мы вставим целый фрагмент в нижнюю панель, но сначала его разработаем:
```
<div style="border: 1px solid black;">
    @{ 
        Person[] my_friends = new Person[]
        {
            new Person { name = "Иванов", birth = "2008" },
            new Person { name = "Петров", birth = "2002" },
            new Person { name = "Сидоров", birth = "2003" },
        };
        foreach (var p in my_friends)
        {
            if (p.name == "Иванов") continue;
            <div>@(p.name) @(p.birth)</div>
        }
    }
</div>
```  
C# раздел начинается в символа '@', это либо блок, как в данном случае, либо @for, @foreach, @if и др. 
Далее идет код на C# и предполагается некоторое исполнение кода, причем с циклами и условиями, в общем - как нормальной программы. А в тех местах, в которых нужно сформировать html-код, этот код непосредственно вставляется от открывающего тега до закрывающего. 

### Урок 3. Поток новостей
Последним тестом было построение списка персон. Списки очень часто являются результатом визуализации, а сами они берутся или из базы данных или как-то формируются. Попробуем сформировать и визуализировать подобный список новостей. 

Что такое новость? Это композиция нескольких текстов и, возможно, иллюстрации или иллюстраций. Все также как и с персоной. Давайте в левой панели сформируем интерктивную "площадку" ввода полей новости. Класс новости определим как (фотографию пока не вставляем):
```
    class SsypNews
    {
        public DateTime dt;
        public string header;
        public string content;
        public string author;
    }
    SsypNews snews = new SsypNews
    {
        header = "",
        content = ""
    };
```  
Наша следующая задача: ввод полей новости. Переменная, которую можно заполнять уже имеется, это snews. Блазор предоставляет прозрачные средства ввода полей с данными. Вот фрагмент, который будет работать на ввод:
```
        <div><input placeholder="заголовок" @bind="snews.header"/></div>
        <div><textarea placeholder="text" @bind="snews.content" /></div>
        <div><button @onclick="ClickOk">OK</button></div>
```
Объясняю что означают эти строчки. Стандартные для HTML поля ввода <input> и <textarea> имеют дополнитлеьные атрибуты. Это placeholder - фоновый текст, используется для обозначения поля или действия. Другой атрибут специальный. Это @bind. То, что он специальный (не используется в стандартном HTML) видно по символу @ впереди. Так вот, @bind устанавливает двунаправленную связь между тем, что введено и переменной, с которой устанавливается связь. В данном случае, связи установлены с соответствующими полями переменной snews. Для завершения ввода, используется кнопка <button>, в этой кнопке специальным атрибутом @onclick, задается действие, которое будет выполнено по нажатию кнопки. В данном случае, будет запущен метод ClickOk().

Еще мы сделаем фрагмент, который отдельно визуализирует запись. Поскольку это действие аналогично визуализации персоны, можно переделать тот фрагмент, получится что-нибудь вроде:
```
        <h3>@(snews.header)</h3>
        <div>@(snews.content)</div>
```
Осталось определить обработку нажатия OK, т.е. метода ClickOk():
```
    void ClickOk()
    {

    }
```
Пока мы ничего не делаем по нажатию, но уже можно испытать. Рекомендую ввод разместить в левой панели, вывод - в правой панели. После запуска программы, если не было существенных ошибок, появятся поля ввода и кнопка. Набирая тексты и нажимая кнопку, убедитесь, что введенные данные визуализируются. Если не удастся оживить программу после многих попыток, можно посмотреть начинайте сборку программу с начала и будьте предельно внимательным. Пока ничего важного вы не сделали, та что можно начинать с убирания всех строчек в Index.razor начиная со второй. 

Наконец, ввод/вывод пройден. Сделаем еще доработку и получим поток новостей (Очень очень прототипный). Сейчас в нижней панели сделаем собственно поток. Поток новостей, это некоторая последовательность элементов того же типа SsypNews. Для начала, достаточно завести переменную List<SsypNews> newsflow = new List<SsypNews>(); Далее, внести перенос новости из snews в этот список при обработке нажатия кнопки. И последнее, сделать визуализацию списка новостей. Итак, вместо кода ClickOk с пустым наполнением, делаем:
```
    List<SsypNews> newsflow = new List<SsypNews>();
    void ClickOk()
    {
        newsflow.Add(snews); 
    }
```
А в нижней панели:
```
    @foreach (var ne in newsflow)
    {
    <div>
        <h3>@(ne.header)</h3>
        <div>@(ne.content)</div>
    </div>
    }
``` 
Запустим программу. В интерфейсе есть два поля для формирования новости. Наберем какой-нибудь текст в этих полях, по ходу набора будем видеть синхронизацию набранных значений с отображением в правой панели. А после того, как будет нажато Ok, появится новость и в нижней панели. Если вместо уже набранной новости набрать следующую новость и нажать Ok, то эта новость добавится к первой. 

### Урок 4. Доработка потока новостей
Вот сейчас надо довести уменье до осознанного. Для этого, настоятельно рекомендую все наработанное в 
Index.razor стереть и повторить разработку. Уверяю вас, вы, скорее всего, будете "спотыкаться" на каждом
шагу. Попробуйте стереть наработанное в Index.razor и на "пустом" поле создать такое же или похожее решение. Вам придется подсматривать в уже написанный код. Подсматривайте, но без copy-past. В этот раз, пишите код самостоятельно. Только тогда вы что-то начнете понимать.  

После успешного восстановления кода ленты новостей, начнем ее доводить и улучшать. Сначала - мелкое улучшение. Не слишком удобно то, что поля ввода не "чистятся" перед следующем вводом. А когда они должны очищаться? Логично, если очистка будет происходить после нажатия Ok. Так что все очень просто - после фиксации значений полей в списке (в ленте), нужно просто значения полей переменной snews превратим в пустую строку, код придумайте сами, это совсем просто. 

Еще одно простое улучшение: теперь не видно смысла в визуализации в правой панели, уберем визуализацию, оставим панель пустой. Также есть смысл изменить порядок визуалиации новостей из потока. Сейчас новости визуализируются с первой до последней, а хорошо бы, как принято, наоборот. Просто заменим цикл на for(;;)

Теперь попробуем изучить вопрос общего пользования лентой новостей. Запустим приложение, появится также интерфейс приложения в дефолтном браузере. Не "гасите" приложение или интерфейс. Теперь убедимся, что автоматически (!) приложение стало многопользовательским. Для этого, в другом браузере в адресной строке наберем то, что (автоматически) набралось в первом. Мы увидим точно такой же интерфейс в приложением. Теперь будем вводить новости через первый интерфейс и через второй. Можно запустить еще произвольное количество таких интерфейсов, все будет также. Эксперименты покажут, что каждый интерфейс независим, ведет свой и только свой поток новостей. 

А можно ли организовать единую ленту новостей? Можно и я покажу как. Дело в том, что если мы хотим иметь что-то общее в разных интерфейсах, надо иметь какие-то общие переменные. Обычно их называют глобальными, в C# это статические переменные. Если посмотреть на нашу программу, становится понятно, что статической переменной мог бы быть список List<SsypNews> newsflow = new List<SsypNews>(); Удивительно, но для такой модификации достаточно дописать слово (модификатор) static перед этим оператором. Попробуйте. Все заработало в многопользовательском режиме! Есть правда неприятность: введенное сообщение на твоем экране появляется сразу, а на других - только после каких-то действий на них. Это общая проблема синхронизации интерфейсов в интерктивный приложениях. В дальнейшем мы узначем как эту трудность преодолеть. 

Однако, наш оптимизационный процесс еще не закончился. Посмотрим на структуру записи SsypNews. Есть еще два поля, которые мы не задействовали, это автор и дата. Идея заключается в том, что эти поля должны быть поставлены автоматически. Автор, это тот пользователь, который работает через этот интерфейс, ну а дата может быть взята из системного времени. Добавим переменную string usr, а в правой панели вставим поле ввода связанное с этой переменной:
```
    @code { string user; }
    <div style="float:right; width:40px;"> <input @bind="user" placeholder="usr"/> </div>
```
Ну и там, где новость переписывается в поток (в процедуре ClickOk) расширим набор записываемых полей:
```
newsflow.Add(new SsypNews { dt = System.DateTime.Now, author = user, header = snews.header, content = snews.content });
```
Понятно, что и визуализацию ленты новостей надо дополнить показом доволнительных полей:
```
    @for (int i = 0; i < newsflow.Count; i++)
    {
        var ne = newsflow[newsflow.Count - i - 1];
        <div>
            <div> @(ne.dt) @(ne.author)</div>
            <h3>@(ne.header)</h3>
            <div>@(ne.content)</div>
        </div>
    }
```
Лента новостей создана

### Урок 5. Компоненты.
Одна из сильный сторон технологии Balzor - это наличие компонентного подхода когда можно отдельно разработать некоторое полезное решение, а потом вставить его на странице или в другой компонент. Это как процедуры - есть описание процедуры, есть ее использование, точнее - использования. И также как для процедур, компоненты блазора могут иметь параметры. Это позволяет и предавать данные "вовнутрь" или передавать параметры настройки. Есть и механизм возвращения "наработанного", т.е. результата. 

Идея заключается в том, что мы можем расставлять компоненты по плоскости размещения также как html-элементы. В нашем случае, дополнительным преимуществом является то, что отдельные компоненты могуть разрабатаваться разными членами команды, а потом легко собраны в единую композицию. 

Сначала подготовим наш личный проект к следующему шагу. Для того, чтобы не уничтожать уже наработанное, поступим просто: преименуем Pages/Index.razor напр. в Pages/Index1.razor и изменим в этом файле только первую строчку на напр. @page "/index1". Запустим, посмотрим. Теперь страницы Index.razor у нас нет и интерфейс "ругается", но если в адресную строку добавить /index1, то страница появится и он именно та, которая нами была сконструирована. Мы сохранили старое, теперь надо сформировать новое. Сначала сделаем новую индексную страницу. Для этого, надо в Обозревателе решений в вашем проекте (у меня это KostyaStart), выделить папку Pages и через правую кномку мышки найти в выпадающем меню Добавить/Компонет Razor, потом снова выбрать "Компонент Razor" и изменить имя создаваемого компонента на Index.razor. Index.razor снова появляется среди страниц, но его еще надо доделать. Вспомним, что в нормальной страничке должна быть первая строчка @page "имя страницы" и добавим строку
```
@page "/"
```
Снова запустим программу и увидем, что тепеь индексная страница появилась, но она пока не слишком заполнена. 

Теперь мы готовы к осваиванию компонентов. Надо 1) создать компонент; 2) вставить компонент для использования. Создавать компонент мы будем в отдельной зоне, для этого еще раз активируем Обозреватель решений, встанем мышкой на проект и нажмем правую кнопку. В выпдающем меню найдем вариант "Добавить/Создать папку", нажмем и назовем папку "Components". Создание компонента делается точно также как мы создавали страничку Index.razor. Только в папке Components. Выделяем, активируем контекстное меню (нажимаем првую кнопку мыши), находим "Добавить/Компонет razor" и устанавилваем навание, напр. TestComp.razor. Если что-то пререпутали, то можно появившееся стереть и создато компонент заново. 

Первуя часть мы сделали, а теперь надо сделать вторую: вставить компонент в композицию. Для этого на (новой) странице Index.razor добавляете элемент с названием компонента. Правда надо не забыть пространство имен, получится что-то вроде:
```
<KostyaStart.Components.TestComp />
```  
Если вы не ошиблись, то внутри индексной страницы, в том месте, в котором вы поставили компонент, содержимое этого компонента и появится!

Теперь будем передавать параметры. Пусть в нашем примере параметром является текст, который передается в компонент, там преобразовывается и визуализируется. Параметры у компонентов указываются в кодовой части указанием вида 
```
@code{
    [Parameter]
    public string inputtext { get; set; }
}
```
Если для компонента определены параметры, то их можно передавать "вовнутрь" через атрибуты элемента:
```
<KostyaStart.Components.TestComp inputtext="Внешний тест для компонета TextComp" />
```
Проанализируйте что делает данный компонент:
```
<div>@("полученный текст: " + inputtext)</div>
<button @onclick="Doit">считать число слов</button>
@if (nwords != -1)
{
    <h1>@("" + nwords)</h1>
}

@code {
    [Parameter] public string inputtext { get; set; }


    private int nwords = -1;
    private void Doit()
    {
        nwords = inputtext.Split(' ').Count();
    }
}
```
Что мы видим? Компонент имеет один текстовый параметр (как раньше). Значение этого параметра выдается компонентом вначале. Потом идет кнопка, по нажатию которой что-то подсчитывается процедурой Doit(). Эта процедура на самом деле подстчиывает число слов разделенных пробелами во введеном тексте. А уже это число выводится большим текстом послед кнопки. Для наглядности, нарисованная компонентом композиция выделена прямоугольником. Попробуйте. 

Возврат вычисленного в компоненте значения осуществляется довольно "хитро". Ничего особенного в этом нет, просто следуйте предложенной схеме. Наработанное из компонента возвращается не напрямую, а через вызов метода, который передается в компонент. Давайте передадим в компонент метод (handler - это обработчик):
```
   [Parameter]
   public EventCallback handler { get; set; } /// (!)
```
Что это нам дает? Мы можем внутри компонента запустить полученный обработчик! Этого достаточно для передачи результатов "наружу". А когда мы должны запустить обработчик? Наверное, после вычисления (появления) того резуьтата, который нужен. В данном примере, в конце метода Doit(). Посучится что-то вроде:
```
    private void Doit()
    {
        nwords = inputtext.Split(' ').Count();
        handler.InvokeAsync(nwords); /// (!!)
    }
```
Итоговый вариант страницы:
```
@page "/"
<h3>Index</h3>
<KostyaStart.Components.TestComp inputtext="Внешний тест для компонета TextComp"
                                 handler="(n) => UseResult((int)n)" />  @* /// (!!!) *@
<h1>Полученный результат: @(result)</h1>

@code {

    private int result;
    private void UseResult(int nwrds)
    {
        result = nwrds;
    }
}
```  
Обратите внимание как обработчик передается в компонент. Выделенные через /// (!) части программы отвечают за возврат результатов через передачу обработчика. 


